Message buses go a level above networks
----------------------------------------------------------------------

Avis provides a publish/subscribe message bus. A message bus
architecture allows you to move up a level from thinking of
communication in terms of protocols and point to point networking, and
think in terms of connectionless communication bus.

Instead of low-level, point-to-point, connection-oriented
communications between a client and a server, a message bus supports
many communications arrangements one to one, one to many, many to
many. Clients simply emit and receive messages on a global bus --
there is no direct connection between clients, they simply receive
messages they've nominated an interest in if another client somewhere
on the bus emits them.

A message bus can be used to implement traditional client-server
remote procedure call (RPC) architectures if needed, but can also
support other kinds of communication requirements, such as message
broadcast (e.g. instant messaging, SNMP, stock tickers, RSS news) and
discovery (service discovery, Bonjour device discovery).

Because the bus can be joined from anywhere on the network and uses a
uniform message format, any client can monitor, consume, modify,
augment, forward, proxy and generate messages, making on-the-fly
extendability and monitoring far more straightforward than with opaque
RPC and multicast-style systems

A standard messaging format means protocols become simpler: you design
the content rather than worry about on-the-wire encoding, network
protocols, etc. The bus architecture also encourages a more stateless
connection between clients and obsoletes the issues of deciding who
initiates a connection, how to handle disconnection and reconnection,
and how to find the service to connect to. And security becomes a
matter of deciding who can and cannot receive which messages and how
they're federated outside.

Why choose Avis?

So, hopefully the above will have convinced you that a message bus
architecture can a good choice for many communication-based
systems. Avis is only one of a number of message bus "middleware"
providers, which include enterprise-standards such as the Java
Messaging System (JMS) and wide-area messaging systems such as
XMPP. So why would you choose Avis over one of these?
 
Avis has two key features to recommend it:

 * It's considerably less complex and lighter-weight than other
   messaging systems, but can scale to large systems.

 * The router is designed for high performance, allowing it to be used
   for applications that send lots of messages and need them delivered
   fast.

It's also an open standard and Free Software, which can't hurt. No
licensing issues, unlimited deployment.


Low overhead
----------------------------------------------------------------------

Avis is very easy to add to a client application. The Avis client
library has a small overhead, both in terms of resources and in terms
of how much code you need to write to do anything with it. This means
deciding to use it has a much lower impact and will not dominate even
a fairly small project as would choosing something like JMS -- you can
set up and use Avis in a few lines of code, no factories, registries,
queues or network configuration needed.

Avis' simplicity works to make it easy to get started, and its
flexibility allows it to scale upwards to more complex things if you
so decide. Once you've set up an Avis server somewhere on the network
for one project, you'll find it can easily be used for other projects
and, by federating it with other routers, scaled up to bigger
networks.


Router speed
----------------------------------------------------------------------

The Avis message router only delivers messages to clients that are
interested in them and, thanks to Avis' subscription language, clients
can usually be specific enough in what they request that they don't
have to receive messages they're not interested in.

Because the router does not support guaranteed delivery, transactions
or durable subscriptions (* explain), and optimises the way it scans
for matching subscriptions, it can scale to very large message
volumes. This allows it to be used for semi real time applications: a
real example uses Avis for sending remote mouse control events to a
display server computer, where speed of delivery is required for the
movement to feel smooth.

When not to use it
----------------------------------------------------------------------

Avis *is* reliable in the sense that is well tested, but does not
provide an absolute guarantee of delivery, just a best-effort
attempt. If this sounds scary, note that many systems can happily and
safely operate without absolutely guaranteed delivery, and that there
is a signficant cost associated with providing such guarantees. These
costs are measured both in delivery speed and in requiring much more
complex insfrastructure: a guaranteed delivery system needs a
persistent message store, tracking for which clients have received
which messages, acknowledgment of message receipt, etc. Such systems
also have a lot of state on the server, which makes server failover,
load-balancing and federation much harder.

If you need absolute guaranteed message delivery or durability, you'll
probably find something like JMS a more appropriate choice, especially
if you're already using a Java Enterprise or .NET system where such a
choice will allow you to integrate better with other components.


Use
----------------------------------------------------------------------

A testament to how an Avis-style message bus works in real use is the
successful adoption of Avis' commercial big brother, Elvin. Elvin has
become a core component of a number of projects at DSTC, DSTO, and
several universities. Avis and Elvin have been used:

 * To implement a wide-area instant messaging and presence network
   across several organisations,

 * To provide communication and service control for smart meeting
   spaces

 * For RSS news dissemenination

 * To route Stock trade notifications

It has also been used on the side in a number of rojects where it
simply provides a convenient way to instrument or otherwise send a
message from a program that is otherwise not communication oriented at
all (e.g. instrumenting a web application).
